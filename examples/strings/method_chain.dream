/// Method chaining example using UFCS
///
/// Method calls like `expr.method(args)` are transformed into
/// `method(expr, args)` where `method` must be in scope.

/// Option type for representing optional values
enum Option<T> {
    Some(T),
    None,
}

/// Safe division that returns Option<int>
pub fn safe_div(a: int, b: int) -> Option<int> {
    if b == 0 {
        None
    } else {
        Some(a / b)
    }
}

/// Unwrap with default value
pub fn unwrap_or<T>(opt: Option<T>, default: T) -> T {
    match opt {
        Some(x) => x,
        None => default,
    }
}

/// Check if option has a value
pub fn is_some<T>(opt: Option<T>) -> bool {
    match opt {
        Some(_) => true,
        None => false,
    }
}

pub fn main() -> atom {
    io::println("Method chaining example");
    io::println("========================");

    // Method chaining: expr.method(args) becomes method(expr, args)
    let result1 = safe_div(10, 2).unwrap_or(0);
    io::format("10 / 2 = ~p~n", [result1]);

    let result2 = safe_div(10, 0).unwrap_or(-1);
    io::format("10 / 0 = ~p (default: -1)~n", [result2]);

    // Check if option has value
    let has_value = safe_div(20, 4).is_some();
    io::format("20 / 4 is_some: ~p~n", [has_value]);

    let no_value = safe_div(20, 0).is_some();
    io::format("20 / 0 is_some: ~p~n", [no_value]);

    // Chained method calls
    let chained = Some(42).unwrap_or(0);
    io::format("Some(42).unwrap_or(0) = ~p~n", [chained]);

    :ok
}
