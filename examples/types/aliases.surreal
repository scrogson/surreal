// Type Aliases Example
//
// Type aliases provide a way to give a name to an existing type.
// They make code more readable and document intent.

mod type_aliases {
    // Simple type alias for a primitive type
    type UserId = int;
    type Username = string;

    // Type alias with union types
    type Status = :ok | :error;
    type Result = :ok | :error | :pending;

    // Type alias for tuple types
    type Point = (int, int);
    type Dimensions = (int, int, int);

    // Type alias for function types
    type Handler = fn(int) -> string;

    // Public type aliases (can be exported)
    pub type ApiResponse = :success | :failure;

    // ========== Generic Type Aliases ==========
    //
    // Type aliases can have type parameters, enabling reusable type patterns.

    // Generic result type - T is substituted when the alias is used
    type MyResult<T> = (:ok, T) | :error;

    // Multiple type parameters
    type Either<L, R> = (:left, L) | (:right, R);

    // Generic pair (same type for both elements)
    type Pair<T> = (T, T);

    // ========== Using Type Aliases ==========

    pub fn create_user(id: UserId, name: Username) -> (UserId, Username) {
        (id, name)
    }

    pub fn get_status(success: bool) -> Status {
        if success { :ok } else { :error }
    }

    pub fn origin() -> Point {
        (0, 0)
    }

    pub fn move_point(p: Point, dx: int, dy: int) -> Point {
        let (x, y) = p;
        (x + dx, y + dy)
    }

    pub fn process_result(r: Result) -> string {
        match r {
            :ok => "Success!",
            :error => "Failed!",
            :pending => "Still working...",
            _ => "Unknown"
        }
    }

    pub fn check_api(ok: bool) -> ApiResponse {
        if ok { :success } else { :failure }
    }

    // ========== Using Generic Type Aliases ==========

    pub fn divide(a: int, b: int) -> MyResult<int> {
        if b == 0 {
            :error
        } else {
            (:ok, a / b)
        }
    }

    pub fn parse_int(s: string) -> Either<string, int> {
        // Simplified - in reality would parse the string
        if s == "42" {
            (:right, 42)
        } else {
            (:left, "parse error")
        }
    }

    pub fn make_pair(x: int) -> Pair<int> {
        (x, x)
    }

    pub fn main() -> :ok {
        // Using simple type aliases
        let user = create_user(42, "alice");
        :io::format("User: ~p~n", [user]);

        let status = get_status(true);
        :io::format("Status: ~p~n", [status]);

        let point = origin();
        :io::format("Origin: ~p~n", [point]);

        let moved = move_point(point, 10, 20);
        :io::format("Moved point: ~p~n", [moved]);

        let result = process_result(:pending);
        :io::format("Result message: ~p~n", [result]);

        let api = check_api(true);
        :io::format("API response: ~p~n", [api]);

        // Using generic type aliases
        :io::format("~n=== Generic Type Aliases ===~n", []);

        // MyResult<int> - T is substituted with int
        let div_result: MyResult<int> = divide(10, 2);
        :io::format("10 / 2 = ~p~n", [div_result]);

        let div_error: MyResult<int> = divide(10, 0);
        :io::format("10 / 0 = ~p~n", [div_error]);

        // Either<string, int> - L=string, R=int
        let parsed: Either<string, int> = parse_int("42");
        :io::format("parse('42') = ~p~n", [parsed]);

        let parse_err: Either<string, int> = parse_int("abc");
        :io::format("parse('abc') = ~p~n", [parse_err]);

        // Pair<int> - both elements are int
        let pair: Pair<int> = make_pair(5);
        :io::format("Pair: ~p~n", [pair]);

        :ok
    }
}
