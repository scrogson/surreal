// Binary/Bit String Syntax example
// Demonstrates Erlang-style binary construction and pattern matching

mod bits {
    use io::{println, format};

    // Create a simple binary with byte values
    pub fn make_bytes() -> binary {
        <<1, 2, 3, 4>>
    }

    // Create a binary with a 16-bit value (big endian by default)
    pub fn make_word() -> binary {
        let value: int = 4660;
        <<value:16>>
    }

    // Create a binary with explicit little endian
    pub fn make_little_endian() -> binary {
        let value: int = 4660;
        <<value:16/little>>
    }

    // Create a binary with signed values
    pub fn make_signed() -> binary {
        let neg: int = 0 - 128;
        <<neg:8/signed>>
    }

    // Combine multiple segment types
    pub fn make_packet() -> binary {
        let header: int = 1;
        let length: int = 256;
        let payload: int = 42;
        <<header:8, length:16/big, payload:32>>
    }

    // Pattern match on binary data
    pub fn parse_header(data: binary) -> int {
        match data {
            <<version:8, _flags:8, _rest:16>> => version,
            _ => 0,
        }
    }

    // Match with specific byte pattern
    pub fn check_magic(data: binary) -> int {
        match data {
            <<66, 77, size:32/little>> => size,
            _ => 0,
        }
    }

    // Empty binary
    pub fn empty_binary() -> binary {
        <<>>
    }

    pub fn main() -> atom {
        println("=== Binary/BitString Example ===");

        format("make_bytes(): ~p~n", [make_bytes()]);
        format("make_word(): ~p~n", [make_word()]);
        format("make_little_endian(): ~p~n", [make_little_endian()]);
        format("make_signed(): ~p~n", [make_signed()]);
        format("make_packet(): ~p~n", [make_packet()]);
        format("empty_binary(): ~p~n", [empty_binary()]);

        println("");
        println("Pattern matching:");

        let data = <<1, 2, 3, 4>>;
        format("parse_header(<<1,2,3,4>>): ~p~n", [parse_header(data)]);

        // "BM" header (66, 77) followed by size 100 in little endian
        let bmp = <<66, 77, 100, 0, 0, 0>>;
        format("check_magic(BMP header): ~p~n", [check_magic(bmp)]);

        :ok
    }
}
