// Erlang sets module bindings
//
// Sets implemented using a hash table.
// See: https://www.erlang.org/doc/man/sets.html

#[name = "sets"]
extern mod sets {
    /// Create a new empty set.
    fn new() -> Any;

    /// Create a new empty set with version option.
    fn new(opts: [Any]) -> Any;

    /// Check if a set is empty.
    fn is_empty(set: Any) -> bool;

    /// Get the number of elements.
    fn size(set: Any) -> int;

    /// Check if term is a set.
    fn is_set(term: Any) -> bool;

    /// Check if element is a member.
    fn is_element(elem: Any, set: Any) -> bool;

    /// Add an element.
    fn add_element(elem: Any, set: Any) -> Any;

    /// Delete an element.
    fn del_element(elem: Any, set: Any) -> Any;

    /// Union of two sets.
    fn union(set1: Any, set2: Any) -> Any;

    /// Union of a list of sets.
    fn union(set_list: [Any]) -> Any;

    /// Intersection of two sets.
    fn intersection(set1: Any, set2: Any) -> Any;

    /// Intersection of a list of sets.
    fn intersection(set_list: [Any]) -> Any;

    /// Subtract set2 from set1.
    fn subtract(set1: Any, set2: Any) -> Any;

    /// Check if set1 is a subset of set2.
    fn is_subset(set1: Any, set2: Any) -> bool;

    /// Check if two sets are disjoint.
    fn is_disjoint(set1: Any, set2: Any) -> bool;

    /// Check if two sets are equal.
    fn is_equal(set1: Any, set2: Any) -> bool;

    /// Convert set to list.
    fn to_list(set: Any) -> [Any];

    /// Create set from list.
    fn from_list(list: [Any]) -> Any;

    /// Create set from list with options.
    fn from_list(list: [Any], opts: [Any]) -> Any;

    /// Filter elements.
    fn filter(pred: fn(Any) -> bool, set: Any) -> Any;

    /// Map a function over elements.
    fn map(fun: fn(Any) -> Any, set: Any) -> Any;

    /// Filter and map in one pass.
    fn filtermap(fun: fn(Any) -> Any, set: Any) -> Any;

    /// Fold over elements.
    fn fold<Acc>(fun: fn(Any, Acc) -> Acc, acc: Acc, set: Any) -> Acc;
}
