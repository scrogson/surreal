// Erlang string module bindings
//
// String processing functions (works with unicode strings).
// See: https://www.erlang.org/doc/man/string.html

#[name = "string"]
extern mod string {
    // ============== Case Conversion ==============

    /// Convert to lowercase.
    fn lowercase(string: Any) -> Any;

    /// Convert to uppercase.
    fn uppercase(string: Any) -> Any;

    /// Convert to titlecase.
    fn titlecase(string: Any) -> Any;

    /// Case-fold for comparison.
    fn casefold(string: Any) -> Any;

    // ============== Trimming ==============

    /// Trim whitespace from both ends.
    fn trim(string: Any) -> Any;

    /// Trim specified characters from both ends.
    fn trim(string: Any, dir: atom) -> Any;

    /// Trim with direction and characters.
    fn trim(string: Any, dir: atom, chars: Any) -> Any;

    /// Chomp trailing newline.
    fn chomp(string: Any) -> Any;

    // ============== Padding ==============

    /// Pad to length (default left).
    fn pad(string: Any, length: int) -> Any;

    /// Pad with direction.
    fn pad(string: Any, length: int, dir: atom) -> Any;

    /// Pad with direction and character.
    fn pad(string: Any, length: int, dir: atom, char: Any) -> Any;

    // ============== Searching ==============

    /// Find substring.
    fn find(string: Any, search_pattern: Any) -> Any;

    /// Find with direction.
    fn find(string: Any, search_pattern: Any, dir: atom) -> Any;

    /// Get prefix.
    fn prefix(string: Any, prefix: Any) -> Any;

    /// Check if string starts with prefix.
    fn is_prefix(prefix: Any, string: Any) -> bool;

    // ============== Splitting/Joining ==============

    /// Split string.
    fn split(string: Any, search_pattern: Any) -> [Any];

    /// Split with direction.
    fn split(string: Any, search_pattern: Any, where: atom) -> [Any];

    /// Lexemes (split by whitespace).
    fn lexemes(string: Any, separators: Any) -> [Any];

    /// Join strings.
    fn join(strings: [Any], separator: Any) -> Any;

    // ============== Replacement ==============

    /// Replace substring.
    fn replace(string: Any, search_pattern: Any, replacement: Any) -> Any;

    /// Replace with direction.
    fn replace(string: Any, search_pattern: Any, replacement: Any, where: atom) -> Any;

    // ============== Length/Slicing ==============

    /// Get string length in grapheme clusters.
    fn length(string: Any) -> int;

    /// Get substring.
    fn slice(string: Any, start: int) -> Any;

    /// Get substring with length.
    fn slice(string: Any, start: int, length: Any) -> Any;

    /// Reverse string.
    fn reverse(string: Any) -> Any;

    // ============== Comparison ==============

    /// Compare strings.
    fn equal(a: Any, b: Any) -> bool;

    /// Compare with case insensitivity option.
    fn equal(a: Any, b: Any, ignore_case: bool) -> bool;

    /// Compare with locale option.
    fn equal(a: Any, b: Any, ignore_case: bool, norm: atom) -> bool;

    // ============== Conversion ==============

    /// Convert to float.
    fn to_float(string: Any) -> Result<float, Any>;

    /// Convert to integer.
    fn to_integer(string: Any) -> Result<int, Any>;

    /// Convert to integer with base.
    fn to_integer(string: Any, base: int) -> Result<int, Any>;

    /// Convert graphemes to codepoints.
    fn to_graphemes(string: Any) -> [Any];

    /// Take graphemes.
    fn take(string: Any, characters: Any) -> Any;

    /// Take with complement.
    fn take(string: Any, characters: Any, complement: bool) -> Any;

    /// Take with complement and direction.
    fn take(string: Any, characters: Any, complement: bool, dir: atom) -> Any;

    /// Check if string is empty.
    fn is_empty(string: Any) -> bool;

    /// Get next grapheme cluster.
    fn next_grapheme(string: Any) -> Any;

    /// Get next codepoint.
    fn next_codepoint(string: Any) -> Any;
}
