// Erlang gb_sets module bindings
//
// General balanced sets.
// See: https://www.erlang.org/doc/man/gb_sets.html

#[name = "gb_sets"]
extern mod gb_sets {
    /// Create an empty set.
    fn empty() -> Any;

    /// Create a new empty set (alias for empty).
    fn new() -> Any;

    /// Create a singleton set.
    fn singleton(elem: Any) -> Any;

    /// Check if set is empty.
    fn is_empty(set: Any) -> bool;

    /// Check if term is a gb_set.
    fn is_set(term: Any) -> bool;

    /// Check if element is a member.
    fn is_member(elem: Any, set: Any) -> bool;

    /// Check if element is a member (alias).
    fn is_element(elem: Any, set: Any) -> bool;

    /// Get the number of elements.
    fn size(set: Any) -> int;

    /// Add an element (error if exists).
    fn add(elem: Any, set: Any) -> Any;

    /// Add an element (alias for add).
    fn add_element(elem: Any, set: Any) -> Any;

    /// Insert an element (allow duplicates).
    fn insert(elem: Any, set: Any) -> Any;

    /// Delete an element (error if not found).
    fn delete(elem: Any, set: Any) -> Any;

    /// Delete an element if present.
    fn delete_any(elem: Any, set: Any) -> Any;

    /// Delete an element (alias).
    fn del_element(elem: Any, set: Any) -> Any;

    /// Take an element (delete and return).
    fn take_any(elem: Any, set: Any) -> Any;

    /// Get the smallest element.
    fn smallest(set: Any) -> Any;

    /// Get the largest element.
    fn largest(set: Any) -> Any;

    /// Take the smallest element.
    fn take_smallest(set: Any) -> (Any, Any);

    /// Take the largest element.
    fn take_largest(set: Any) -> (Any, Any);

    /// Union of two sets.
    fn union(set1: Any, set2: Any) -> Any;

    /// Union of a list of sets.
    fn union(set_list: [Any]) -> Any;

    /// Intersection of two sets.
    fn intersection(set1: Any, set2: Any) -> Any;

    /// Intersection of a list of sets.
    fn intersection(set_list: [Any]) -> Any;

    /// Subtract set2 from set1.
    fn subtract(set1: Any, set2: Any) -> Any;

    /// Check if set1 is a subset of set2.
    fn is_subset(set1: Any, set2: Any) -> bool;

    /// Check if two sets are disjoint.
    fn is_disjoint(set1: Any, set2: Any) -> bool;

    /// Check if two sets are equal.
    fn is_equal(set1: Any, set2: Any) -> bool;

    /// Convert set to list.
    fn to_list(set: Any) -> [Any];

    /// Create set from list.
    fn from_list(list: [Any]) -> Any;

    /// Create set from ordset (ordered list).
    fn from_ordset(list: [Any]) -> Any;

    /// Balance the tree.
    fn balance(set: Any) -> Any;

    /// Filter elements.
    fn filter(pred: fn(Any) -> bool, set: Any) -> Any;

    /// Fold over elements.
    fn fold<Acc>(fun: fn(Any, Acc) -> Acc, acc: Acc, set: Any) -> Acc;

    /// Get an iterator.
    fn iterator(set: Any) -> Any;

    /// Get an iterator from a specific element.
    fn iterator_from(elem: Any, set: Any) -> Any;

    /// Get next from iterator.
    fn next(iter: Any) -> Any;
}
