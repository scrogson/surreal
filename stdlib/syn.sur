// syn - Parsing library for proc_macro
//
// Provides structured types for working with derive macro input,
// similar to Rust's syn crate.
//
// ## Usage
//
// ```surreal
// use syn::{parse_derive_input, DeriveInput, Data, Fields};
//
// #[proc_macro_derive(MyDerive)]
// pub fn my_derive(input: any) -> any {
//     let derive_input = parse_derive_input(input);
//     let name = derive_input.ident;
//     let fields = get_struct_fields(derive_input);
//     // ...
// }
// ```

use erlang::std::erlang as erl;
use erlang::std::lists as erl_lists;
//
// ## Input Format
//
// Derive macros receive input as TokenStream (list of tokens):
// ```
// [{keyword, pub}, {keyword, struct}, {type_ident, 'Name'}, {group, brace, [...]}]
// ```
//
// Token types:
// - `{keyword, atom}` - Keywords like pub, struct, enum
// - `{type_ident, atom}` - Type identifiers (PascalCase)
// - `{ident, atom}` - Identifiers (lowercase)
// - `{punct, binary}` - Punctuation like <<":">>, <<",">>, <<"->">>
// - `{group, delimiter, tokens}` - Grouped tokens (brace, paren, bracket, angle)

// =============================================================================
// Core Types (as records/maps for pattern matching)
// =============================================================================

/// Parsed input for a derive macro.
///
/// Fields:
/// - ident: atom - the name of the struct/enum
/// - generics: Generics - generic type parameters
/// - data: Data - struct or enum data
pub struct DeriveInput {
    ident: Atom,
    generics: Generics,
    data: Data,
}

/// Generic type parameters.
pub struct Generics {
    params: [TypeParam],
}

/// A generic type parameter with optional bounds.
pub struct TypeParam {
    ident: Atom,
    bounds: [Atom],
}

/// The data portion of a DeriveInput.
pub enum Data {
    /// A struct
    Struct(DataStruct),
    /// An enum
    Enum(DataEnum),
}

/// Data for a struct.
pub struct DataStruct {
    fields: Fields,
}

/// Data for an enum.
pub struct DataEnum {
    variants: [Variant],
}

/// Fields of a struct.
pub enum Fields {
    /// Named fields: `{ x: int, y: int }`
    Named([Field]),
    /// Unnamed fields (tuple struct): `(int, string)`
    Unnamed([Field]),
    /// Unit struct: no fields
    Unit,
}

/// A single field of a struct.
/// Note: ident is Option<Atom> at runtime but typed as `Any` to avoid
/// cross-module type resolution issues during stdlib compilation.
pub struct Field {
    ident: Any,  // Option<Atom> - None for tuple struct fields
    is_pub: bool,
    ty: Any,  // Type information (as token or keyword)
}

/// An enum variant.
pub struct Variant {
    ident: Atom,
    fields: Fields,
}

// =============================================================================
// Token Stream Parsing
// =============================================================================

/// Parse a TokenStream into a DeriveInput struct.
///
/// TokenStream format:
/// `[{keyword, pub}, {keyword, struct}, {type_ident, 'Name'}, ...]`
pub fn parse_derive_input(tokens: Any) -> DeriveInput {
    // Create parser state
    let state = { tokens: tokens, pos: 0 };

    // Skip optional 'pub' keyword
    let state = skip_keyword(state, :pub);

    // Expect 'struct' or 'enum' keyword
    let (state, kind) = expect_keyword_one_of(state, [:struct, :enum]);

    // Expect type identifier (the name)
    let (state, ident) = expect_type_ident(state);

    // Parse optional generics <T, U>
    let (state, generics) = parse_generics_from_tokens(state);

    // Parse the body
    let data = if kind == :struct {
        parse_struct_body(state)
    } else {
        parse_enum_body(state)
    };

    DeriveInput { ident: ident, generics: generics, data: data }
}

/// Skip a specific keyword if present.
fn skip_keyword(state: Any, kw: Atom) -> Any {
    let tokens = state.tokens;
    if erl::length(tokens) == 0 {
        state
    } else {
        let token = erl::hd(tokens);
        if is_keyword_token(token, kw) {
            { tokens: erl::tl(tokens), pos: state.pos + 1 }
        } else {
            state
        }
    }
}

/// Check if a token is a specific keyword.
fn is_keyword_token(token: Any, kw: Atom) -> bool {
    if erl::is_tuple(token) {
        let tag = erl::element(1, token);
        if tag == :keyword {
            erl::element(2, token) == kw
        } else {
            false
        }
    } else {
        false
    }
}

/// Expect one of the given keywords.
fn expect_keyword_one_of(state: Any, keywords: [Atom]) -> (Any, Atom) {
    let tokens = state.tokens;
    let token = erl::hd(tokens);
    let tag = erl::element(1, token);
    if tag == :keyword {
        let kw = erl::element(2, token);
        if erl_lists::member(kw, keywords) {
            ({ tokens: erl::tl(tokens), pos: state.pos + 1 }, kw)
        } else {
            // Return first keyword as default (error case)
            (state, erl::hd(keywords))
        }
    } else {
        (state, erl::hd(keywords))
    }
}

/// Expect a type identifier token.
fn expect_type_ident(state: Any) -> (Any, Atom) {
    let tokens = state.tokens;
    let token = erl::hd(tokens);
    let tag = erl::element(1, token);
    if tag == :type_ident {
        let name = erl::element(2, token);
        ({ tokens: erl::tl(tokens), pos: state.pos + 1 }, name)
    } else {
        // Error - return placeholder
        (state, :unknown)
    }
}

/// Expect an identifier token.
fn expect_ident(state: Any) -> (Any, Atom) {
    let tokens = state.tokens;
    if erl::length(tokens) == 0 {
        (state, :unknown)
    } else {
        let token = erl::hd(tokens);
        let tag = erl::element(1, token);
        if tag == :ident {
            let name = erl::element(2, token);
            ({ tokens: erl::tl(tokens), pos: state.pos + 1 }, name)
        } else {
            (state, :unknown)
        }
    }
}

/// Parse generic type parameters from tokens.
fn parse_generics_from_tokens(state: Any) -> (Any, Generics) {
    let tokens = state.tokens;
    if erl::length(tokens) == 0 {
        (state, Generics { params: [] })
    } else {
        let token = erl::hd(tokens);
        // Check for angle group: {group, angle, [...]}
        if is_group_token(token, :angle) {
            let inner_tokens = erl::element(3, token);
            let params = parse_type_params(inner_tokens);
            ({ tokens: erl::tl(tokens), pos: state.pos + 1 }, Generics { params: params })
        } else {
            (state, Generics { params: [] })
        }
    }
}

/// Check if a token is a group with specific delimiter.
fn is_group_token(token: Any, delim: Atom) -> bool {
    if erl::is_tuple(token) {
        let tag = erl::element(1, token);
        if tag == :group {
            erl::element(2, token) == delim
        } else {
            false
        }
    } else {
        false
    }
}

/// Parse type parameters from inner tokens of angle group.
fn parse_type_params(tokens: Any) -> [TypeParam] {
    // Split by comma and parse each
    let groups = split_by_punct(tokens, <<",">>);
    erl_lists::filtermap(|group| {
        if erl::length(group) > 0 {
            let first = erl::hd(group);
            let tag = erl::element(1, first);
            if tag == :type_ident {
                let name = erl::element(2, first);
                // TODO: parse bounds after ':'
                (true, TypeParam { ident: name, bounds: [] })
            } else {
                false
            }
        } else {
            false
        }
    }, groups)
}

/// Split tokens by a punctuation character.
fn split_by_punct(tokens: Any, punct: Binary) -> [[Any]] {
    split_by_punct_acc(tokens, punct, [], [])
}

fn split_by_punct_acc(tokens: Any, punct: Binary, current: [Any], result: [[Any]]) -> [[Any]] {
    if erl::length(tokens) == 0 {
        // Add final group if non-empty
        if erl::length(current) > 0 {
            erl_lists::append(result, [erl_lists::reverse(current)])
        } else {
            result
        }
    } else {
        let token = erl::hd(tokens);
        let rest = erl::tl(tokens);
        if is_punct_token(token, punct) {
            // End current group, start new one
            let new_result = if erl::length(current) > 0 {
                erl_lists::append(result, [erl_lists::reverse(current)])
            } else {
                result
            };
            split_by_punct_acc(rest, punct, [], new_result)
        } else {
            split_by_punct_acc(rest, punct, [token | current], result)
        }
    }
}

/// Check if a token is specific punctuation.
fn is_punct_token(token: Any, punct: Binary) -> bool {
    if erl::is_tuple(token) {
        let tag = erl::element(1, token);
        if tag == :punct {
            erl::element(2, token) == punct
        } else {
            false
        }
    } else {
        false
    }
}

/// Parse struct body from brace group.
fn parse_struct_body(state: Any) -> Data {
    let tokens = state.tokens;
    if erl::length(tokens) == 0 {
        Struct(DataStruct { fields: Unit })
    } else {
        let token = erl::hd(tokens);
        if is_group_token(token, :brace) {
            let inner_tokens = erl::element(3, token);
            let fields = parse_struct_fields(inner_tokens);
            Struct(DataStruct { fields: fields })
        } else if is_group_token(token, :paren) {
            // Tuple struct
            let inner_tokens = erl::element(3, token);
            let fields = parse_tuple_fields(inner_tokens);
            Struct(DataStruct { fields: fields })
        } else {
            // Unit struct
            Struct(DataStruct { fields: Unit })
        }
    }
}

/// Parse struct fields from inner tokens.
fn parse_struct_fields(tokens: Any) -> Fields {
    let groups = split_by_punct(tokens, <<",">>);
    let fields = erl_lists::filtermap(|group| {
        parse_field_from_tokens(group)
    }, groups);
    Named(fields)
}

/// Parse a single field from tokens.
/// Format: name : type
fn parse_field_from_tokens(tokens: Any) -> (bool, Field) | bool {
    if erl::length(tokens) < 3 {
        false
    } else {
        let first = erl::hd(tokens);
        let tag = erl::element(1, first);
        if tag == :ident {
            let name = erl::element(2, first);
            // Skip the colon and get the type
            let rest = erl::tl(tokens);
            if erl::length(rest) > 0 {
                let maybe_colon = erl::hd(rest);
                if is_punct_token(maybe_colon, <<":">>) {
                    let type_tokens = erl::tl(rest);
                    let ty = tokens_to_type(type_tokens);
                    (true, Field { ident: Some(name), is_pub: true, ty: ty })
                } else {
                    false
                }
            } else {
                false
            }
        } else {
            false
        }
    }
}

/// Parse tuple struct fields (unnamed).
fn parse_tuple_fields(tokens: Any) -> Fields {
    let groups = split_by_punct(tokens, <<",">>);
    let fields = erl_lists::filtermap(|group| {
        if erl::length(group) > 0 {
            let ty = tokens_to_type(group);
            (true, Field { ident: None, is_pub: true, ty: ty })
        } else {
            false
        }
    }, groups);
    Unnamed(fields)
}

/// Convert type tokens to a type representation.
/// For now, just returns the first token's value for simple types.
fn tokens_to_type(tokens: Any) -> Any {
    if erl::length(tokens) == 0 {
        :any
    } else {
        let first = erl::hd(tokens);
        let tag = erl::element(1, first);
        if tag == :keyword {
            // Primitive type like int, string, bool
            erl::element(2, first)
        } else if tag == :type_ident {
            // Named type like User, Option
            erl::element(2, first)
        } else {
            :any
        }
    }
}

/// Parse enum body from brace group.
fn parse_enum_body(state: Any) -> Data {
    let tokens = state.tokens;
    if erl::length(tokens) == 0 {
        Enum(DataEnum { variants: [] })
    } else {
        let token = erl::hd(tokens);
        if is_group_token(token, :brace) {
            let inner_tokens = erl::element(3, token);
            let variants = parse_enum_variants(inner_tokens);
            Enum(DataEnum { variants: variants })
        } else {
            Enum(DataEnum { variants: [] })
        }
    }
}

/// Parse enum variants from inner tokens.
fn parse_enum_variants(tokens: Any) -> [Variant] {
    let groups = split_by_punct(tokens, <<",">>);
    erl_lists::filtermap(|group| {
        parse_variant_from_tokens(group)
    }, groups)
}

/// Parse a single variant from tokens.
fn parse_variant_from_tokens(tokens: Any) -> (bool, Variant) | bool {
    if erl::length(tokens) == 0 {
        false
    } else {
        let first = erl::hd(tokens);
        let tag = erl::element(1, first);
        if tag == :type_ident {
            let name = erl::element(2, first);
            let rest = erl::tl(tokens);
            let fields = if erl::length(rest) > 0 {
                let next = erl::hd(rest);
                if is_group_token(next, :paren) {
                    // Tuple variant
                    let inner = erl::element(3, next);
                    parse_tuple_fields(inner)
                } else if is_group_token(next, :brace) {
                    // Struct variant
                    let inner = erl::element(3, next);
                    parse_struct_fields(inner)
                } else {
                    Unit
                }
            } else {
                Unit
            };
            (true, Variant { ident: name, fields: fields })
        } else {
            false
        }
    }
}

// =============================================================================
// Convenience Functions
// =============================================================================

/// Get the struct fields from a DeriveInput.
/// Returns an empty list if not a struct or unit struct.
pub fn get_struct_fields(input: DeriveInput) -> [Field] {
    match input.data {
        Struct(s) => match s.fields {
            Named(fields) => fields,
            Unnamed(fields) => fields,
            Unit => [],
            _ => [],
        },
        Enum(_) => [],
        _ => [],
    }
}

/// Get the enum variants from a DeriveInput.
/// Returns an empty list if not an enum.
pub fn get_enum_variants(input: DeriveInput) -> [Variant] {
    match input.data {
        Struct(_) => [],
        Enum(e) => e.variants,
        _ => [],
    }
}

/// Check if the input is a struct.
pub fn is_struct(input: DeriveInput) -> bool {
    match input.data {
        Struct(_) => true,
        Enum(_) => false,
        _ => false,
    }
}

/// Check if the input is an enum.
pub fn is_enum(input: DeriveInput) -> bool {
    match input.data {
        Struct(_) => false,
        Enum(_) => true,
        _ => false,
    }
}

/// Get field names from a list of fields.
/// Returns atoms for named fields, skips unnamed fields.
pub fn field_names(fields: [Field]) -> [Atom] {
    erl_lists::filtermap(|f| {
        // f.ident is Option<atom>: {:Some, name} or :None
        if erl::is_tuple(f.ident) {
            (true, erl::element(2, f.ident))
        } else {
            false
        }
    }, fields)
}

/// Iterate over named fields with their names.
/// Calls the function with (field_name, field) for each named field.
pub fn each_named_field(fields: [Field], func: fn(Atom, Field) -> Any) -> [Any] {
    erl_lists::filtermap(|f| {
        // f.ident is Option<atom>: {:Some, name} or :None
        if erl::is_tuple(f.ident) {
            let name = erl::element(2, f.ident);
            (true, func(name, f))
        } else {
            false
        }
    }, fields)
}
