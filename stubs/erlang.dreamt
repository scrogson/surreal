// Erlang standard library type stubs for Dream
// These declarations enable type checking for FFI calls to Erlang

extern mod erlang {
    // Process management
    fn spawn(fun: fn() -> any) -> pid;
    fn spawn_link(fun: fn() -> any) -> pid;
    fn self() -> pid;
    fn exit(reason: any) -> any;
    fn link(pid: pid) -> bool;
    fn unlink(pid: pid) -> bool;
    fn is_process_alive(pid: pid) -> bool;
    fn monitor(process: atom, pid: pid) -> ref;
    fn demonitor(ref: ref) -> bool;
    fn process_flag(flag: atom, value: any) -> any;
    fn register(name: atom, pid: pid) -> bool;
    fn unregister(name: atom) -> bool;
    fn whereis(name: atom) -> pid;
    fn registered() -> [atom];

    // Message passing
    fn send(dest: pid, msg: any) -> any;

    // Arithmetic
    fn abs(x: int) -> int;
    fn max(a: any, b: any) -> any;
    fn min(a: any, b: any) -> any;
    fn rem(a: int, b: int) -> int;

    // Type conversions
    fn atom_to_list(atom: atom) -> [int];
    fn list_to_atom(list: [int]) -> atom;
    fn integer_to_list(n: int) -> [int];
    fn list_to_integer(list: [int]) -> int;
    fn float_to_list(f: any) -> [int];
    fn list_to_float(list: [int]) -> any;
    fn binary_to_list(bin: binary) -> [int];
    fn list_to_binary(list: [int]) -> binary;
    fn atom_to_binary(atom: atom) -> binary;
    fn binary_to_atom(bin: binary) -> atom;
    fn term_to_binary(term: any) -> binary;
    fn binary_to_term(bin: binary) -> any;

    // Type checks
    fn is_atom(term: any) -> bool;
    fn is_binary(term: any) -> bool;
    fn is_boolean(term: any) -> bool;
    fn is_float(term: any) -> bool;
    fn is_function(term: any) -> bool;
    fn is_integer(term: any) -> bool;
    fn is_list(term: any) -> bool;
    fn is_map(term: any) -> bool;
    fn is_number(term: any) -> bool;
    fn is_pid(term: any) -> bool;
    fn is_port(term: any) -> bool;
    fn is_reference(term: any) -> bool;
    fn is_tuple(term: any) -> bool;

    // References
    fn make_ref() -> ref;

    // Tuples
    fn tuple_size(tuple: any) -> int;
    fn element(n: int, tuple: any) -> any;
    fn setelement(n: int, tuple: any, value: any) -> any;

    // Binary/Bit operations
    fn byte_size(bin: binary) -> int;
    fn bit_size(bin: binary) -> int;

    // System
    fn now() -> (int, int, int);
    fn monotonic_time() -> int;
    fn system_time() -> int;
    fn unique_integer() -> int;
    fn halt() -> any;
    fn halt(status: int) -> any;

    // Error handling
    fn error(reason: any) -> any;
    fn throw(reason: any) -> any;

    // Apply
    fn apply(module: atom, function: atom, args: [any]) -> any;
}

extern mod lists {
    fn append<T>(list1: [T], list2: [T]) -> [T];
    fn concat<T>(lists: [[T]]) -> [T];
    fn delete<T>(elem: T, list: [T]) -> [T];
    fn duplicate<T>(n: int, elem: T) -> [T];
    fn filter<T>(pred: fn(T) -> bool, list: [T]) -> [T];
    fn flatten<T>(list: [T]) -> [T];
    fn foldl<T, Acc>(fun: fn(T, Acc) -> Acc, acc: Acc, list: [T]) -> Acc;
    fn foldr<T, Acc>(fun: fn(T, Acc) -> Acc, acc: Acc, list: [T]) -> Acc;
    fn foreach<T>(fun: fn(T) -> any, list: [T]) -> atom;
    fn keyfind<K>(key: K, n: int, list: [any]) -> any;
    fn keystore<K>(key: K, n: int, list: [any], tuple: any) -> [any];
    fn last<T>(list: [T]) -> T;
    fn map<T, U>(fun: fn(T) -> U, list: [T]) -> [U];
    fn member<T>(elem: T, list: [T]) -> bool;
    fn nth<T>(n: int, list: [T]) -> T;
    fn nthtail<T>(n: int, list: [T]) -> [T];
    fn reverse<T>(list: [T]) -> [T];
    fn sort<T>(list: [T]) -> [T];
    fn split<T>(n: int, list: [T]) -> ([T], [T]);
    fn sum(list: [int]) -> int;
    fn usort<T>(list: [T]) -> [T];
    fn zip<A, B>(list1: [A], list2: [B]) -> [(A, B)];
    fn zipwith<A, B, C>(fun: fn(A, B) -> C, list1: [A], list2: [B]) -> [C];
}

extern mod maps {
    fn new<K, V>() -> map;
    fn get<K, V>(key: K, map: map) -> V;
    fn get<K, V>(key: K, map: map, default: V) -> V;
    fn put<K, V>(key: K, value: V, map: map) -> map;
    fn remove<K>(key: K, map: map) -> map;
    fn keys<K>(map: map) -> [K];
    fn values<V>(map: map) -> [V];
    fn to_list<K, V>(map: map) -> [(K, V)];
    fn from_list<K, V>(list: [(K, V)]) -> map;
    fn is_key<K>(key: K, map: map) -> bool;
    fn size(map: map) -> int;
    fn merge(map1: map, map2: map) -> map;
    fn fold<K, V, Acc>(fun: fn(K, V, Acc) -> Acc, acc: Acc, map: map) -> Acc;
    fn map<K, V, V2>(fun: fn(K, V) -> V2, map: map) -> map;
    fn filter<K, V>(pred: fn(K, V) -> bool, map: map) -> map;
}

extern mod io {
    fn format(format: string, args: [any]) -> atom;
    fn format(device: any, format: string, args: [any]) -> atom;
    fn fread(prompt: string, format: string) -> any;
    fn get_line(prompt: string) -> string;
    fn nl() -> atom;
    fn put_chars(chars: string) -> atom;
}

extern mod file {
    fn read_file(filename: string) -> any;
    fn write_file(filename: string, data: binary) -> any;
    fn delete(filename: string) -> any;
    fn rename(source: string, dest: string) -> any;
    fn make_dir(dir: string) -> any;
    fn del_dir(dir: string) -> any;
    fn list_dir(dir: string) -> any;
    fn read_file_info(filename: string) -> any;
}

extern mod timer {
    fn sleep(milliseconds: int) -> atom;
    fn send_after(time: int, dest: pid, msg: any) -> any;
    fn send_interval(time: int, dest: pid, msg: any) -> any;
    fn cancel(ref: any) -> any;
}

extern mod string {
    fn concat(str1: string, str2: string) -> string;
    fn length(str: string) -> int;
    fn substr(str: string, start: int, len: int) -> string;
    fn to_upper(str: string) -> string;
    fn to_lower(str: string) -> string;
    fn trim(str: string) -> string;
    fn split(str: string, sep: string) -> [string];
    fn join(list: [string], sep: string) -> string;
}

// Note: Erlang's 'binary' module - renamed to avoid keyword conflict
// Use :binary::copy etc. in actual FFI calls
extern mod binary_mod {
    fn copy(bin: binary) -> binary;
    fn part(bin: binary, pos: int, len: int) -> binary;
    fn split(bin: binary, pattern: binary) -> [binary];
    fn match_pattern(bin: binary, pattern: binary) -> any;
}

extern mod gen_server {
    fn start_link(module: atom, args: any, options: [any]) -> any;
    fn call(server: pid, request: any) -> any;
    fn call(server: pid, request: any, timeout: int) -> any;
    fn cast(server: pid, request: any) -> atom;
    fn reply(from: any, reply: any) -> atom;
    fn stop(server: pid) -> atom;
}

extern mod gen_statem {
    fn start_link(module: atom, args: any, options: [any]) -> any;
    fn call(server: pid, request: any) -> any;
    fn cast(server: pid, request: any) -> atom;
    fn reply(from: any, reply: any) -> atom;
    fn stop(server: pid) -> atom;
}

extern mod supervisor {
    fn start_link(module: atom, args: any) -> any;
    fn start_child(sup: pid, child_spec: any) -> any;
    fn terminate_child(sup: pid, id: any) -> any;
    fn restart_child(sup: pid, id: any) -> any;
    fn delete_child(sup: pid, id: any) -> any;
    fn which_children(sup: pid) -> [any];
    fn count_children(sup: pid) -> [any];
}

extern mod ets {
    // Note: ets tables are opaque references, using 'any' for table type
    fn new(name: atom, options: [any]) -> any;
    fn insert<T>(table: any, object: T) -> bool;
    fn lookup<T>(table: any, key: any) -> [T];
    fn delete(table: any) -> bool;
    fn delete<K>(table: any, key: K) -> bool;
    fn member<K>(table: any, key: K) -> bool;
    fn first<K>(table: any) -> K;
    fn next<K>(table: any, key: K) -> K;
    fn tab2list<T>(table: any) -> [T];
}

extern mod crypto {
    fn hash(hash_type: atom, data: binary) -> binary;
    fn mac(mac_type: atom, subtype: atom, key: binary, data: binary) -> binary;
    fn strong_rand_bytes(n: int) -> binary;
}

extern mod rand {
    fn uniform() -> any;
    fn uniform(n: int) -> int;
    fn seed(algo: atom) -> any;
}
